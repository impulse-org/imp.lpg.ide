<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns:st1="urn:schemas-microsoft-com:office:smarttags"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 10">
<meta name=Originator content="Microsoft Word 10">
<link rel=File-List href="index_files/filelist.xml">
<title>Getting Started with JikesPG</title>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="place"/>
<o:SmartTagType namespaceuri="urn:schemas-microsoft-com:office:smarttags"
 name="country-region"/>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Gerry Fisher</o:Author>
  <o:LastAuthor>Chris Laffra</o:LastAuthor>
  <o:Revision>2</o:Revision>
  <o:TotalTime>6797</o:TotalTime>
  <o:LastPrinted>2004-08-10T01:05:00Z</o:LastPrinted>
  <o:Created>2004-08-18T15:16:00Z</o:Created>
  <o:LastSaved>2004-08-18T15:16:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>7443</o:Words>
  <o:Characters>42430</o:Characters>
  <o:Company>IBM</o:Company>
  <o:Lines>353</o:Lines>
  <o:Paragraphs>99</o:Paragraphs>
  <o:CharactersWithSpaces>49774</o:CharactersWithSpaces>
  <o:Version>10.4219</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:ApplyBreakingRules/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if !mso]><object
 classid="clsid:38481807-CA0E-42D2-BF39-B33AF135CC4D" id=ieooui></object>
<style>
st1\:*{behavior:url(#ieooui) }
</style>
<![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;
	mso-font-charset:2;
	mso-generic-font-family:auto;
	mso-font-pitch:variable;
	mso-font-signature:0 268435456 0 0 -2147483648 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:16.0pt;
	font-family:Arial;
	mso-font-kerning:16.0pt;
	font-weight:bold;}
h2
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:2;
	font-size:14.0pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;}
h3
	{mso-style-next:Normal;
	margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:3;
	font-size:13.0pt;
	font-family:Arial;
	font-weight:bold;}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 3.0in right 6.0in;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoFooter, li.MsoFooter, div.MsoFooter
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	tab-stops:center 3.0in right 6.0in;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoPlainText, li.MsoPlainText, div.MsoPlainText
	{mso-style-link:" Char1";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Courier New";
	mso-fareast-font-family:"Times New Roman";}
p
	{mso-style-link:" Char";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
span.Char1
	{mso-style-name:" Char1";
	mso-style-link:"Plain Text";
	font-family:"Courier New";
	mso-ascii-font-family:"Courier New";
	mso-hansi-font-family:"Courier New";
	mso-bidi-font-family:"Courier New";
	mso-ansi-language:EN-US;
	mso-fareast-language:EN-US;
	mso-bidi-language:AR-SA;}
span.Char
	{mso-style-name:" Char";
	mso-style-link:"Normal \(Web\)";
	mso-ansi-font-size:12.0pt;
	mso-bidi-font-size:12.0pt;
	mso-ansi-language:EN-US;
	mso-fareast-language:EN-US;
	mso-bidi-language:AR-SA;}
 /* Page Definitions */
 @page
	{mso-footnote-separator:url("index_files/header.htm") fs;
	mso-footnote-continuation-separator:url("index_files/header.htm") fcs;
	mso-endnote-separator:url("index_files/header.htm") es;
	mso-endnote-continuation-separator:url("index_files/header.htm") ecs;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-even-footer:url("index_files/header.htm") ef1;
	mso-footer:url("index_files/header.htm") f1;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:-132;
	mso-list-type:simple;
	mso-list-template-ids:1352700690;}
@list l0:level1
	{mso-level-tab-stop:1.25in;
	mso-level-number-position:left;
	margin-left:1.25in;
	text-indent:-.25in;}
@list l1
	{mso-list-id:-131;
	mso-list-type:simple;
	mso-list-template-ids:803513452;}
@list l1:level1
	{mso-level-tab-stop:1.0in;
	mso-level-number-position:left;
	margin-left:1.0in;
	text-indent:-.25in;}
@list l2
	{mso-list-id:-130;
	mso-list-type:simple;
	mso-list-template-ids:-530556134;}
@list l2:level1
	{mso-level-tab-stop:.75in;
	mso-level-number-position:left;
	margin-left:.75in;
	text-indent:-.25in;}
@list l3
	{mso-list-id:-129;
	mso-list-type:simple;
	mso-list-template-ids:1687035248;}
@list l3:level1
	{mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;}
@list l4
	{mso-list-id:-128;
	mso-list-type:simple;
	mso-list-template-ids:754100012;}
@list l4:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:1.25in;
	mso-level-number-position:left;
	margin-left:1.25in;
	text-indent:-.25in;
	font-family:Symbol;}
@list l5
	{mso-list-id:-127;
	mso-list-type:simple;
	mso-list-template-ids:-660675038;}
@list l5:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:1.0in;
	mso-level-number-position:left;
	margin-left:1.0in;
	text-indent:-.25in;
	font-family:Symbol;}
@list l6
	{mso-list-id:-126;
	mso-list-type:simple;
	mso-list-template-ids:-21703678;}
@list l6:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.75in;
	mso-level-number-position:left;
	margin-left:.75in;
	text-indent:-.25in;
	font-family:Symbol;}
@list l7
	{mso-list-id:-125;
	mso-list-type:simple;
	mso-list-template-ids:-128536160;}
@list l7:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
@list l8
	{mso-list-id:-120;
	mso-list-type:simple;
	mso-list-template-ids:1313084556;}
@list l8:level1
	{mso-level-tab-stop:.25in;
	mso-level-number-position:left;
	margin-left:.25in;
	text-indent:-.25in;}
@list l9
	{mso-list-id:-119;
	mso-list-type:simple;
	mso-list-template-ids:-1366510852;}
@list l9:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.25in;
	mso-level-number-position:left;
	margin-left:.25in;
	text-indent:-.25in;
	font-family:Symbol;}
@list l10
	{mso-list-id:141121235;
	mso-list-type:hybrid;
	mso-list-template-ids:825492638 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l10:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
@list l11
	{mso-list-id:1526867255;
	mso-list-type:hybrid;
	mso-list-template-ids:-240078126 67698689 67698691 67698693 67698689 67698691 67698693 67698689 67698691 67698693;}
@list l11:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	font-family:Symbol;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="2050"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<h1 align=center style='text-align:center'>Getting Started with LPG</h1>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>LPG (a.k.a. JikesPG) is a LR parser generator that you can
use to build automatically lexers and parsers for LALR(k) languages.<span
style='mso-spacerun:yes'>  </span>Lexing and parsing actions may be written in
almost any programming language including Java, C and C++ , although here we
only consider actions and parsers written in Java.<span
style='mso-spacerun:yes'>  </span>The LPG system is much like LEX and YACC in
its use of LR parsing, but it is also like ANTLR in its overall structure and
its approach to lexical analysis.<span style='mso-spacerun:yes'>  </span>We
hope that LPG will be a highly usable and efficient replacement for ANTLR, CUP
and similar systems.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Constructing a parser is generally quite a complicated
process in which many detailed issues must be addressed.<span
style='mso-spacerun:yes'>  </span>Of course, a parser generator, such as LPG,
is intended to simplify and partially automate the task, but the workings and
use of generator itself are difficult to explain and understand.<span
style='mso-spacerun:yes'>  </span>In this document we explain the use of LPG<span
style='mso-spacerun:yes'>  </span>using an example lexer and parser for a little
expression grammar called <b>LEG</b>.<span style='mso-spacerun:yes'>  </span>We
do not explain in detail the various options for LPG , the various files it
generates and its runtime.<span style='mso-spacerun:yes'>  </span>Understanding
will come, we hope, from the examples.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h2>The Little Expression Grammar (LEG) Example</h2>

<p class=MsoNormal>Suppose you want to build a lexer and parser for a simple
C-like expression language, which we will call LEG.<span
style='mso-spacerun:yes'>  </span>The LEG language is specified by a grammar
written in standard BNF.<span style='mso-spacerun:yes'>  </span>With LPG you
specify the grammar rules and associated processing in a text file with a “.g”
extension, although any extension may be used (an alternative is “.lpg”).<span
style='mso-spacerun:yes'>  </span>You also specify the lexical analyzer in a
similar way.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>We have included the LEG example in this distribution.<span
style='mso-spacerun:yes'>  </span>You may want to compile and run it before
delving into the details.<span style='mso-spacerun:yes'>  </span>We’ll do this
from the command line.</p>

<p class=MsoNormal><b><span style='font-size:13.0pt;font-family:Arial'><o:p>&nbsp;</o:p></span></b></p>

<h3>Running the LEG Example</h3>

<p class=MsoNormal>First run LPG on the lexer grammar file, <b>leglexer.g</b> .<span
style='mso-spacerun:yes'>  </span>Here is the command line output (but we have
suppressed some of the options and statistics). </p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>C:\legexample\leg&gt;lpg leglexer.g</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Options in effect for leglexer.g:</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>ACTION-BLOCK=(&quot;LegLexer.java&quot;,&quot;/.&quot;,&quot;./&quot;)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>FILE-PREFIX=&quot;LegLexer&quot;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>LALR=5 NOLIST
PACKAGE=&quot;leg&quot; PARSE-TABLE=&quot;lpg.*&quot; PREFIX=&quot;Char_&quot;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>PRS-FILE=&quot;LegLexerprs.java&quot; SYM-FILE=&quot;LegLexersym.java&quot;<span
style='mso-spacerun:yes'>  </span></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>TABLE=JAVA</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>leglexer.g is LALR(5).</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Number of Terminals: 73</p>

<p class=MsoPlainText>Number of Nonterminals: 28</p>

<p class=MsoPlainText>Number of Productions: 170</p>

<p class=MsoPlainText>Number of Items: 378</p>

<p class=MsoPlainText>Number of States: 30</p>

<p class=MsoPlainText>Number of look-ahead states: 18</p>

<p class=MsoPlainText>Number of Shift actions: 80</p>

<p class=MsoPlainText>Number of Goto actions: 14</p>

<p class=MsoPlainText>Number of Shift/Reduce actions: 427</p>

<p class=MsoPlainText>Number of Goto/Reduce actions: 50</p>

<p class=MsoPlainText>Number of Reduce actions: 1068</p>

<p class=MsoPlainText>Number of Shift-Reduce conflicts: 0</p>

<p class=MsoPlainText>Number of Reduce-Reduce conflicts: 0</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>. . .</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Based on the options given in <b>leglexer.g</b><span
style='mso-spacerun:yes'>  </span>grammar file, LPG has generated three Java
files.<span style='mso-spacerun:yes'>  </span>The names of these files are
prefixed with the string given by the “file-prefix” option, which here is <b>LegLexer</b>.<span
style='mso-spacerun:yes'>  </span>The “sym-file”, <b>LegLexersym.java</b>, is
an interface defining the lexer’s terminal symbols (characters and character
ranges).<span style='mso-spacerun:yes'>  </span>The “prs-file”, <b>LegLexerprs.java</b>,
is a class defining the tables the LPG parser will use.<span
style='mso-spacerun:yes'>  </span>The file <b>LegLexer.java</b>, specified in
the “action-block” option, is the class defining the actions taken when rules
are reduced.<span style='mso-spacerun:yes'>  </span>For a lexer, the actions generate
the tokens to be parsed.<span style='mso-spacerun:yes'>  </span>The actions are
Java statements enclosed with the brackets “/.” and “./”.<span
style='mso-spacerun:yes'>  </span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The “package” option identifies the Java package for Leg
(which is <b>leg</b>) and this package declaration is placed in every Java file
LPG generates. The “prs-table” option, “lpg.*” tells LPG that in the “prs-file”
this package (here the LPG runtime) must be imported.<span
style='mso-spacerun:yes'>  </span>The “table” option indicates programming
language that the parse tables are to be accessed from (in our example it is
Java).</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Finally, there are various statistics about the grammar and
the tables used to parse it.<span style='mso-spacerun:yes'>  </span>In
particular, notice that this grammar is confirmed to be LALR(5).<span
style='mso-spacerun:yes'>  </span>We discuss below the important “template” and
“export-terminals” options.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Next run LPG on the Leg parser, <b>legparser.g</b>.<span
style='mso-spacerun:yes'>  </span>The (somewhat modified) output is:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>C:\legexample\leg&gt;lpg legparser.g</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Options in effect for legparser.g:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>ACTION-BLOCK=(&quot;LegParser.java&quot;,&quot;/.&quot;,&quot;./&quot;)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>BACKTRACK
LALR=1 TABLE=JAVA</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>SERIALIZE <span
style='mso-spacerun:yes'> </span></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>DAT-FILE=&quot;LegParserdcl.data&quot;<span style='mso-spacerun:yes'> 
</span>DAT-DIRECTORY=&quot;../bin&quot; </p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>FILE-PREFIX=&quot;LegParser&quot;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>PACKAGE=&quot;leg&quot;<span style='mso-spacerun:yes'> 
</span>PARSE-TABLE=&quot;lpg.*&quot; </p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>PRS-FILE=&quot;LegParserprs.java&quot;<span
style='mso-spacerun:yes'>   </span></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>SYM-FILE=&quot;LegParsersym.java&quot; </p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>*** Shift/reduce conflict on &quot;LEFT_BRACKET&quot;
with rule 21</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>legparser.g is not LALR(1).</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Number of Terminals: 21</p>

<p class=MsoPlainText>Number of Nonterminals: 9</p>

<p class=MsoPlainText>Number of Productions: 23</p>

<p class=MsoPlainText>Number of Shift-Reduce conflicts: 1</p>

<p class=MsoPlainText>Number of Reduce-Reduce conflicts: 0</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>For the Leg parser the same Java “prs”, “sym” and “action”
files are produced (but using the “file prefix” <b>LegParser</b>).<span
style='mso-spacerun:yes'>  </span>The “backtrack” option signals that the LPG
backtracking parser will try all possible alternatives when there are
conflicts.<span style='mso-spacerun:yes'>  </span>The “serialize” option tells
LPG to serialize the parse tables to the “dat-file” (with extension “data”)
instead of including them as initialization in the “prs-file”.<span
style='mso-spacerun:yes'>  </span>The Leg parser data file is <b>LegParserdcl.data</b>
and LPG places it in the “dat-directory”, which is our bin directory, so it can
be accessed on the class path. </p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><span style='mso-spacerun:yes'> </span>The Leg parser
grammar has a conflict that cannot be resolved using just one token of
look-ahead.<span style='mso-spacerun:yes'>  </span>In a certain state the
parser cannot determine whether to shift or reduce the “[“.<span
style='mso-spacerun:yes'>  </span>The backtracking parser will try both
possibilities in turn and choose the first one that allows the parse to advance
through the rest of the input or signal an error if neither does.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Next compile the Leg example Java files which will place the
class and data files in the bin directory.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>C:\legexample\leg&gt;javac -d ../bin </p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                       
</span>-classpath ../bin;../bin/lpg.jar <span
style='mso-spacerun:yes'> </span>*.java</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Finally, execute the main program on the input file <b>test.leg</b>.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>C:\legexample\leg&gt;type test.leg</p>

<p class=MsoPlainText>(1)<span style='mso-spacerun:yes'>  </span>= expression;</p>

<p class=MsoPlainText>(2)<span style='mso-spacerun:yes'>  </span>if (
expression ) then</p>

<p class=MsoPlainText>(3)<span style='mso-spacerun:yes'>     </span>expression
= 1; </p>

<p class=MsoPlainText>(4)<span style='mso-spacerun:yes'>  </span>else
expression = 0; </p>

<p class=MsoPlainText>(5)<span style='mso-spacerun:yes'>  </span>end if;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     </span>. . .</p>

<p class=MsoPlainText>(10) while expression do</p>

<p class=MsoPlainText>(11) whi le expression do</p>

<p class=MsoPlainText>(12)<span style='mso-spacerun:yes'>    </span>if
expression then</p>

<p class=MsoPlainText>(13)<span style='mso-spacerun:yes'>         </span>break;</p>

<p class=MsoPlainText>(14)<span style='mso-spacerun:yes'>    </span>else</p>

<p class=MsoPlainText>(15)<span style='mso-spacerun:yes'>    </span>end if;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>C:\legexample\leg&gt;java -cp ../bin;../bin/lpg.jar
leg.Main test.leg</p>

<p class=MsoPlainText>test.leg:1:2:1:2: &quot;variable&quot;inserted before
this token</p>

<p class=MsoPlainText>test.leg:11:1:11:6: &quot;WHILE&quot;formed from merged
tokens</p>

<p class=MsoPlainText>test.leg:11:1:28:42: &quot;END WHILE ;&quot;inserted to
complete scope</p>

<p class=MsoPlainText>test.leg:10:1:28:42: &quot;END WHILE ;&quot;inserted to
complete scope</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The test file has syntax errors so we see the error messages
produced by the diagnosing parser.<span style='mso-spacerun:yes'>  </span>There
are options for dumping the tokens and showing the AST defined in the <b>Option</b>
class which you can explore.<span style='mso-spacerun:yes'>  </span>You may
want to try test2.leg, a correct example, and dump its AST.<span
style='mso-spacerun:yes'>  </span>The command (and part of the output) is:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>C:\legexample\leg&gt;java -cp ../bin;../bin/lpg.jar
leg.Main -da test2.leg</p>

<p class=MsoPlainText>****Begin Parse</p>

<p class=MsoPlainText>#1 (Block):<span style='mso-spacerun:yes'>  </span>#4 #15
#23 #24 #26 #33 #38 #43 #48 #51 #54 #58 #69</p>

<p class=MsoPlainText>#4 (AssignmentStatement):<span style='mso-spacerun:yes'> 
</span>#2 = #3</p>

<p class=MsoPlainText>#2 (VariableExpression):<span style='mso-spacerun:yes'> 
</span>variable</p>

<p class=MsoPlainText>#3 (VariableExpression):<span style='mso-spacerun:yes'> 
</span>expression</p>

<p class=MsoPlainText>#15 (IfStatement):<span style='mso-spacerun:yes'> 
</span>if #6 then #7 else #11 end if ;</p>

<p class=MsoPlainText>#6 (ParenthesizedExpression):<span
style='mso-spacerun:yes'>  </span>( #5 )</p>

<p class=MsoPlainText>#5 (VariableExpression):<span style='mso-spacerun:yes'> 
</span>expression</p>

<p class=MsoPlainText>#7 (Block):<span style='mso-spacerun:yes'>  </span>#10</p>

<p class=MsoPlainText>#10 (AssignmentStatement):<span
style='mso-spacerun:yes'>  </span>#8 = #9</p>

<p class=MsoPlainText>#8 (VariableExpression):<span style='mso-spacerun:yes'> 
</span>expression</p>

<p class=MsoPlainText>#9 (ConstantExpression):<span style='mso-spacerun:yes'> 
</span>1</p>

<p class=MsoPlainText>#11 (Block):<span style='mso-spacerun:yes'>  </span>#14</p>

<p class=MsoPlainText>#14 (AssignmentStatement):<span
style='mso-spacerun:yes'>  </span>#12 = #13</p>

<p class=MsoPlainText>#12 (VariableExpression):<span style='mso-spacerun:yes'> 
</span>expression</p>

<p class=MsoPlainText>#13 (ConstantExpression):<span style='mso-spacerun:yes'> 
</span>0</p>

<p class=MsoPlainText>#23 (WhileStatement):<span style='mso-spacerun:yes'> 
</span>while #16<span style='mso-spacerun:yes'>  </span>17 end while ;</p>

<p class=MsoPlainText>#16 (VariableExpression):<span style='mso-spacerun:yes'> 
</span>expression</p>

<p class=MsoPlainText>. . .</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h2>The LEG Parser</h2>

<h3>Grammar Rules</h3>

<p class=MsoNormal>The grammar file has several “sections”, the most important
of which is designated <b>“$Rules</b>”.<span style='mso-spacerun:yes'> 
</span>Here is the <b>$Rules</b> section for LEG:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Rules</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>block ::=
$empty</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>block ::= block
statement</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>statement ::=
variable = expression ;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>statement ::=
IF expression THEN block ELSE block END IF ;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>statement ::=
WHILE expression DO block END WHILE ;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>statement ::=
BREAK ;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>statement ::=
array_declaration ;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>array_declaration
::= IDENTIFIER [ ]</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>array_declaration ::= array_declaration [ ]</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>expression ::=
term</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>expression ::=
expression + term</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>expression ::=
expression - term</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>term ::= factor</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>term ::= term /
factor</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>term ::= term *
factor</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'> </span><span
style='mso-spacerun:yes'>   </span>factor ::= variable</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>factor ::=
CONSTANT</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>factor ::= (
expression )</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>variable ::=
IDENTIFIER</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>variable ::=
variable [ expression ]</p>

<p class=MsoPlainText>$End</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The rules contain “terminal” and “nonterminal” symbols.<span
style='mso-spacerun:yes'>  </span>The symbols “block” and “factor” are examples
of nonterminal symbols, while “<span class=Char1>WHILE</span>” and “<span
class=Char1>;</span>” are terminal symbols.<span style='mso-spacerun:yes'> 
</span>The symbol “<b>$empty</b>” is special; it means the rule is an empty
rule – i.e., has no right hand side.<span style='mso-spacerun:yes'> 
</span>Here each rule is stated separately.<span style='mso-spacerun:yes'> 
</span>But you can use alternatives – for example:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>term ::= factor</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           </span>| term /
factor</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           </span>| term *
factor</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>There is no special notation for grouping, e.g. “<span
class=Char1>(A|B|C)</span>”, repetition, e.g.<span style='mso-spacerun:yes'> 
</span>“<span class=Char1>*</span>” or “<span class=Char1>+</span>”,<span
style='mso-spacerun:yes'>  </span>or optional choice, e.g., “<span class=Char1>?</span>”.<span
style='mso-spacerun:yes'>  </span>However, these conveniences can be easily
expressed with additional rules.<span style='mso-spacerun:yes'>  </span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>Terminal and Non-terminal Symbols</h3>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>In LPG symbols (terminal and non-terminal) are represented
internally as integers.<span style='mso-spacerun:yes'>  </span>Terminal symbols
represent <span style='mso-spacerun:yes'> </span>“tokens” that are produced by
scanning or lexically analyzing an input text source. (How tokens may be
produced by a LPG generated parser is described below).<span
style='mso-spacerun:yes'>  </span>Non-terminal symbols, such as “expression”,
represent syntactic classes.<span style='mso-spacerun:yes'>  </span>A special
file, called the “sym” file will be generated by LPG that contains the mapping
of terminal symbols to integers.<span style='mso-spacerun:yes'>  </span>Here is
what the Java LEG sym file looks like:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>package leg;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>interface LegParsersym {</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public final
static int</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_ASSIGN =
13,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>TK_LEFT_BRACKET = 7,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>TK_RIGHT_BRACKET = 9,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_SEMICOLON
= 1,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_PLUS = 2,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_MINUS = 3,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_DIVIDE =
10,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_STAR = 11,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>TK_LEFT_PARENTHESIS = 14,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>TK_RIGHT_PARENTHESIS = 15,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_IDENTIFIER
= 4,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_CONSTANT =
16,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_EOF_SYMBOL
= 17,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_IF = 5,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_THEN = 18,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_ELSE = 19,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_END = 12,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_WHILE = 6,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_DO = 20,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_BREAK = 8,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>TK_ERROR_SYMBOL = 21,</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>NUM_TOKENS =
21;</p>

<p class=MsoPlainText>}</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>First notice that LPG has generated the Java interface “<b>LegParsersym</b>”
declared in the package “<span class=Char1>leg</span>”.<span
style='mso-spacerun:yes'>  </span>Two LPG options are needed to make this
happen, the package option and the file prefix option.<span
style='mso-spacerun:yes'>  </span>These are specified at the beginning of the
grammar file as follows:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>%options package=leg</p>

<p class=MsoPlainText>%options file_prefix=LegParser</p>

<p class=MsoPlainText>%options prefix=TK_</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Since this is the “sym” file, the interface name and the
file name are the same: “<b>LegParsersym</b>”.<span style='mso-spacerun:yes'> 
</span>Also shown here is the prefix option, used to prefix terminal symbol
names as explained below.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Next note that the symbols for special characters, such as “<span
class=Char1>;</span>” have been changed and all symbols have been given the
prefix “<span class=Char1><b>TK_</b></span>”.<span style='mso-spacerun:yes'> 
</span>You want to name the symbols in such a way that they can be used as Java
program identifiers, so special characters and Java reserved words, such as “<span
class=Char1>break</span>”, must not be used to name symbols.<span
style='mso-spacerun:yes'>  </span>LPG gives you two ways to avoid trouble when
naming terminal symbols.<span style='mso-spacerun:yes'>  </span>First, there is
the prefix option that lets you define a prefix (also a suffix) for the symbols
that appear in the sym file.<span style='mso-spacerun:yes'>  </span>Second, in
the section in which terminal symbols are declared, “<b>$Terminals</b>” (or in
another section called “<b>$Alias</b>”) <span
style='mso-spacerun:yes'> </span>you can associate a terminal symbol name with
another name or sequence of characters.<span style='mso-spacerun:yes'> 
</span>For example, the <b>$Terminal</b> section of the LEG grammar is:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Terminals</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>SEMICOLON ::= ;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>ASSIGN ::= =</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>LEFT_BRACKET
::= [</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>RIGHT_BRACKET
::= ]</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>PLUS ::= +</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>MINUS ::= -</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>DIVIDE ::= /</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>STAR ::= *</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>LEFT_PARENTHESIS ::= (</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>RIGHT_PARENTHESIS ::= )</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>IDENTIFIER</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>CONSTANT</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>IF THEN ELSE
END WHILE DO BREAK</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>ERROR_SYMBOL</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>EOF_SYMBOL</p>

<p class=MsoPlainText>$End</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Hopefully it is clear, for example, <span
style='mso-spacerun:yes'> </span>that “<span class=Char1>SEMICOLON</span>” is
the terminal symbol and “<span class=Char1>;</span>” is the alias.<span
style='mso-spacerun:yes'>  </span>In a rule the alias symbol can be used in
place of the terminal symbol.<span style='mso-spacerun:yes'>  </span>Even
non-terminal symbols can have aliases.<span style='mso-spacerun:yes'>  </span>You
can have more than one alias for a given symbol.<span
style='mso-spacerun:yes'>  </span>You could put additional terminal symbol aliases
(and non-terminal symbol aliases) in the <b>$Alias</b> section as follows:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Alias</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>eostmt <span
style='mso-spacerun:yes'> </span>::= SEMICOLON</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>identifier ::=
IDENTIFIER</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>expr<span
style='mso-spacerun:yes'>   </span><span style='mso-spacerun:yes'> </span>::=
expression</p>

<p class=MsoPlainText>$End</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>(By the way, it probably helps readability to enclose
special characters with single quotes, e.g., writing <span class=Char1>‘[‘</span>
instead of the square bracket alone).</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>Rule Actions</h3>

<p class=MsoNormal>A LPG parser recognizes a syntactic class (represented by a
non-terminal symbol) by parsing the text for the right-hand side (rhs) of a
rule defining that class and “reducing” the rhs to the left-hand side (lhs) of
that rule.<span style='mso-spacerun:yes'>  </span>The user can specify a “rule
action” (sometimes called a “semantic” or “syntactic” action) to be executed
whenever the rule is reduced.<span style='mso-spacerun:yes'>  </span>Rule
actions typically produce an “abstract” representation of the source syntax.<span
style='mso-spacerun:yes'>  </span>Often this abstract syntax is expressed as a
tree and so is called an “Abstract Syntax Tree” or <b>AST</b> for short.<span
style='mso-spacerun:yes'>  </span>In fact, the AST can be whatever you want it
to be, and, indeed, it can be completely absent.<span
style='mso-spacerun:yes'>  </span>If you use LPG for a parser that does lexical
analysis, as we shall see below, your parser’s AST will not be a tree but
rather a list of tokens .<span style='mso-spacerun:yes'>  </span>Here is an
example of how the AST is specified in the LEG grammar:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>block ::=
$empty</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>/.$BeginAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>          </span><span
style='mso-spacerun:yes'>  </span>AstBlock block = new AstBlock();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>$setSym1(block);</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>  </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>block ::= block
statement</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>/.$BeginAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>AstBlock
block = (AstBlock) $getSym(1);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>block.statement.add($getSym(2));</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>  </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>statement ::=
variable = expression ;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>/.$BeginAction</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:.5in'>AstAssignmentStatement
assignment =</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:.5in'><span
style='mso-spacerun:yes'> </span><span style='mso-tab-count:1'>     </span>new AstAssignmentStatement();</p>

<p class=MsoPlainText style='margin-left:.5in;text-indent:.5in'>assignment.lhs
= $getSym(1);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>assignment.equal
= $getToken(2);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>assignment.rhs
= $getSym(3);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>assignment.semicolon
= $getToken(4);</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>$setSym1(assignment);</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span><span style='mso-spacerun:yes'>  </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>./</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>A “<b>block</b>” consists of a sequence of “<b>statements</b>”
(possibly empty)<span style='mso-spacerun:yes'>  </span>and its AST consists
essentially of a list of “<b>statement</b>” AST’s.<span
style='mso-spacerun:yes'>  </span>Notice that “<b>block</b>” is the “Start”
symbol of the LEG grammar, so what the parser returns (assuming no errors) is
the AST for the input “block”.<span style='mso-spacerun:yes'>  </span>You may
specify the start symbol in a “<b>$Start</b>” section or as the lhs of the
first rule in the <b>$Rule</b> section.<span style='mso-spacerun:yes'> 
</span>Also illustrated above is the AST generation for the LEG assignment
statement.<span style='mso-spacerun:yes'>  </span>The class “<b>AstAssignmentStatement</b>”
extends the “<b>Ast</b>” class, just as “<b>AstBlock</b>” does.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>When specifying a rule action, you need to separate its text
from the text of the rule.<span style='mso-spacerun:yes'>  </span>This is done
with a pair of delimiters you are free to choose (well almost).<span
style='mso-spacerun:yes'>  </span>In the LEG example the action delimiters are
“<b>/.</b>” And “<b>./</b>”.<span style='mso-spacerun:yes'>    </span>These
delimiters are specified using the “<b>action</b>” option.<span
style='mso-spacerun:yes'>  </span>For the LEG parser this option is:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>%options action=(&quot;LegParser.java&quot;,
&quot;/.&quot;, &quot;./&quot;)</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>In addition to the action delimiters, the “<b>action</b>”
option specifies the file containing the rule action method (procedure or
function) that the code for each action will be associated with or folded
into.<span style='mso-spacerun:yes'>  </span>For the LEG parser, this file
defines the Java class, LegParser, which implements the rule action
method.<span style='mso-spacerun:yes'>  </span>This class and its specification
is somewhat complicated and will be described below.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>To help specify the AST generating actions, we use two
macros, <b>$BeginAction</b> and <b>$EndAction</b>.<span
style='mso-spacerun:yes'>  </span>These are defined in a special section called
<b>$Define</b><span class=Char1>.</span> Here is the <b>$Define</b> section for
the LEG example:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$Header</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/.</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>//</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>// Rule
$rule_number:<span style='mso-spacerun:yes'>  </span>$rule_text</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>//./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>$DefaultAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/. $Header</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>case $rule_number: ./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>$BeginAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>/.$DefaultAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>{./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>/.<span style='mso-spacerun:yes'>         
</span>}</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>            </span>break; ./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$NoAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/. $Header</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>case $rule_number:</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>             </span><span
style='mso-spacerun:yes'>       </span>break; ./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>$BeginActions</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/.</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>public void ruleAction( int ruleNumber)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               
</span>switch(ruleNumber)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$EndActions</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>/.</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>default:</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>    </span>break;</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>}</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>return;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>$setSym1 /.btParser.setSym1./</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>$getSym /.(Ast)btParser.getSym./</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>$getToken /.btParser.getToken./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>./</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The last two macros, <b>$BeginActions</b> and <b>$EndActions</b>,
are used to define the beginning and end of the <b>ruleAction</b> method.<span
style='mso-spacerun:yes'>  </span>The method consists of a switch statement
with a case for each rule with actions.<span style='mso-spacerun:yes'> 
</span>The <b>$BeginActions</b> and <b>$EndActions</b> macros essentially
bracket the action with a case alternative.<span style='mso-spacerun:yes'> 
</span>The <span class=Char1>$Header</span> macro provides the rule number and
text to document the action in the generated Java file.<span
style='mso-spacerun:yes'>  </span>The use of the symbol access macros, <b>$setSym1</b>,<span
style='mso-spacerun:yes'>  </span><span class=Char1>$getSym</span>, and <b>$getToken</b><span
class=Char1>,</span> is explained below.<span style='mso-spacerun:yes'> 
</span>There are also several LPG predefined macros that facilitate references
to rule properties.<span style='mso-spacerun:yes'>  </span>In this example we
see the macros <b>$rule_number</b> and <b>$rule_text</b>.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Here is the Java code LPG generates for the actions shown
above:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public void
ruleAction( int ruleNumber)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>switch(ruleNumber)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'> </span><span
style='mso-spacerun:yes'>    </span>. . .</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>//</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>// Rule 3:<span
style='mso-spacerun:yes'>  </span>block ::=</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>//</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>case 3:
</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>    </span>AstBlock
block = new AstBlock();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span><span
style='mso-spacerun:yes'>    </span>btParser.setSym1(block);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>break; </p>

<p class=MsoPlainText><span style='mso-spacerun:yes'> </span></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>//</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>// Rule 4:<span
style='mso-spacerun:yes'>  </span>block ::= block statement</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>//</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>case 4:
</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span><span
style='mso-spacerun:yes'>    </span>AstBlock block = (AstBlock) (Ast)btParser.getSym(1);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span><span
style='mso-spacerun:yes'>    </span>block.statement.add((Ast)btParser.getSym(2));</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>break;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>//</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>// Rule 5:<span
style='mso-spacerun:yes'>  </span>statement ::= variable ASSIGN expression
SEMICOLON</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>//</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>case 5:
</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               
</span>AstAssignmentStatement assignment = new </p>

<p class=MsoPlainText><span
style='mso-spacerun:yes'>                                   
</span>AstAssignmentStatement();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               
</span>assignment.lhs = (Ast)btParser.getSym(1);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               
</span>assignment.equal = btParser.getToken(2);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               
</span>assignment.rhs = (Ast)btParser.getSym(3);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               
</span>assignment.semicolon = btParser.getToken(4);</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>btParser.setSym1(assignment);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>break;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>. . .</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>default:</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span><span style='mso-spacerun:yes'>  </span>break;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>}</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>return;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>When the parser recognizes the right hand side of a rule,
the parser calls the rule action method giving it the rule number as argument.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>While parsing the input tokens, LPG maintains two stacks: a
“symbol” stack, for non-terminal symbol AST, and a “token” stack for the tokens
not yet fully reduced.<span style='mso-spacerun:yes'>  </span>A parser “shift”
action pushes the current token onto the token stack, while a rule reduce
action effectively replaces the AST generated for the rule’s right hand side
non-terminals with the AST for the left hand side (i.e., the rule itself).<span
style='mso-spacerun:yes'>  </span>The LPG parser (in our example “<b>btParser</b>”)
has methods to get symbols and tokens (<b>getSym</b> and <b>getToken</b>) from
these stacks and to set the symbol stack with the generated AST (<b>setSym1</b>).<span
style='mso-spacerun:yes'>  </span>The macros, <b>$setSym1</b>,<span
style='mso-spacerun:yes'>  </span><b>$getSym</b>, and <b>$getToken</b>, enable
you to use these methods without identifying the specific LPG parser being used
(there are actually three of them).</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The symbols in the right hand side of a rule are numbered
from left to right starting with one.<span style='mso-spacerun:yes'>  </span>If
the <i>i</i>th symbol is a terminal symbol,<span style='mso-spacerun:yes'> 
</span>its token is accessed by <b>getToken(i)</b>.<span
style='mso-spacerun:yes'>  </span>If the <i>i</i>th symbol is a non-terminal
symbol,<span style='mso-spacerun:yes'>  </span>its AST is accessed as <span
class=Char1>getSym(<i>i</i>)</span> and its leftmost token <b>getToken(i)</b>.<span
style='mso-spacerun:yes'>  </span>To set the AST for the rule, use the method <b>setSym1(astObject)</b>.<span
style='mso-spacerun:yes'>  </span>The <b>getToken</b> method returns an <b>int</b>
value while the <b>getSym1</b> method returns an instance of <b>Object</b>.<span
style='mso-spacerun:yes'>  </span>The argument of <b>setSym1</b> is also an
instance of <b>Object</b>.<span style='mso-spacerun:yes'>  </span>This
generality is necessary since the AST class cannot be predefined (when you get
a symbol, you may need to cast it to your AST type). </p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>The Action Class</h3>

<p class=MsoNormal>The rule actions described above are contained in an “action
class”, which in the LEG example is called <b>LegParser</b>.<span
style='mso-spacerun:yes'>  </span>The purpose of this class is to implement the
LPG <b>RuleAction</b> interface (which specifies the <b>ruleAction</b> method)
and a <b>parser</b> method that invokes an LPG parser on the token stream.<span
style='mso-spacerun:yes'>  </span>The rule actions may be implemented by a
single method (as in the LEG example) or by an array of action methods (one for
each rule) defined in inner classes and accessed through an array of instances
(we’ll not discuss this approach here).<span style='mso-spacerun:yes'> 
</span>The action class is (incompletely) specified in a <b>$Headers</b>
section.<span style='mso-spacerun:yes'>  </span>Here is the LEG action class:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Headers</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>/.</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>package leg;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>import lpg.*;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>import
java.util.ArrayList;<o:p></o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>public
class LegParser implements RuleAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>LexStream prsStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>ParseTable prs;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>BacktrackingParser btParser;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>public LegParser(LexStream
prsStream)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               
</span>this.prsStream = prsStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               
</span>this.prs = new LegParserprs();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>public Ast
parser()</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>try</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>btParser = new BacktrackingParser(</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                          
</span>(TokenStream)prsStream, prs, </p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                          
</span>(RuleAction)this);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               
</span>catch (BadParseSymFileException e)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>prsStream.reportError(0,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                        
</span>&quot;BadParseSymFileException&quot;);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>return null;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   </span><span
style='mso-spacerun:yes'>   </span><span
style='mso-spacerun:yes'>          </span>try</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:1'>    </span><span
style='mso-spacerun:yes'>       </span><span
style='mso-spacerun:yes'> </span>return (Ast) btParser.parse();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>catch
(BadParseException e)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>prsStream.reset(e.error_token); </p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>DiagnoseParser diagnoseParser = new</p>

<p class=MsoPlainText><span
style='mso-spacerun:yes'>                                  </span><span
style='mso-spacerun:yes'> </span>DiagnoseParser(prsStream, prs);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>diagnoseParser.diagnose(e.error_token);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>return
null;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$End<o:p></o:p></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The <b>LegParser</b> class implements the LPG interface <b>RuleAction</b>
whose <b>ruleAction</b> method is called by the LPG parsers.<span
style='mso-spacerun:yes'>  </span>The specification of this class in the <b>$Headers</b>
section is incomplete since the body of the <b>ruleAction</b> method is woven
throughout the rules.<span style='mso-spacerun:yes'>  </span>As shown above,
two macros, <b>$BeginActions</b> and <b>$EndActions</b>, are defined to delimit
the start and end of this method. The <b>$BeginActions</b> macro is called at
the start of the <b>$Rules</b> section and the <b>$EndActions</b> macro is
placed in the <b>$Trailers</b> section (within which the <b>LegParser</b> class
is completed).</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The <b>LegParser</b> class has three attributes needed for
parsing.<span style='mso-spacerun:yes'>  </span>The token stream (here an
instance of the class <b>LexStream</b>), the parse table class (containing the
tables and constants needed for parsing the token stream) and the LPG parser
itself (in this case the LPG <b>BacktrackingParser</b>).<span
style='mso-spacerun:yes'>  </span>The <b>LegParser</b> constructor is passed
the token stream and it creates an instance of the LPG generated parse table
class, <b>LegParserprs</b>, that contains the various parse tables, constants
and access methods, thereby implementing the LPG <b>ParseTable</b> interface.<span
style='mso-spacerun:yes'>  </span>The method <b>parser</b> creates the
backtracking parser and invokes it.<span style='mso-spacerun:yes'>  </span>If
the <b>parser</b> encounters a syntax error, it throws a <b>BadParseException</b>.<span
style='mso-spacerun:yes'>  </span>The parser method catches this exception and
calls the LPG <b>DiagnoseParser</b> to find all syntax errors in the
input.<span style='mso-spacerun:yes'>  </span>If the diagnosing parser is
called, no actions are executed and hence no AST is generated.<o:p></o:p></p>

<h3>The Token Stream</h3>

<p class=MsoNormal>The input to the LPG parser is an array (or array list) of
tokens.<span style='mso-spacerun:yes'>  </span>The token array is produced by
scanning<span style='mso-spacerun:yes'>  </span>and tokenizing an input array
of characters.<span style='mso-spacerun:yes'>  </span>The LPG parsers assume
that the token array contains <b>all</b> of the tokens.<span
style='mso-spacerun:yes'>  </span>This facilitates look-ahead determination and
syntactic error recovery.<span style='mso-spacerun:yes'>  </span>You can modify
the deterministic parser to get tokens on demand, but we do not recommend doing
that.<span style='mso-spacerun:yes'>  </span>To the LPG parser a token is
simply an index into the token array.<span style='mso-spacerun:yes'>  </span>As
for the token itself, there is only one attribute that is relevant to parsing:
the token <b>kind</b>.<span style='mso-spacerun:yes'>  </span>The kind is the
identity of the token as a terminal symbol.<span style='mso-spacerun:yes'> 
</span>LPG associates with each terminal symbol its token kind, which is
written out to the “<b>sym</b>” interface file (in our example, <b>LegParsersym.java</b>).</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Typically (though not always) you will create a token class
containing the attributes you need for parsing and semantic analysis.<span
style='mso-spacerun:yes'>  </span>In addition to the “<b>kind</b>” attribute,
token location attributes, which specify input source and placement, are often necessary
as well, especially for error reporting.<span style='mso-spacerun:yes'> 
</span>In the LEG example the Token class is written as follows:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>class Token {</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>int kind = 0;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>int startOffset
= 0;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>int endOffset =
0;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>Token() {}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>Token(int
startOffset, int endOffset, int kind)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>this.startOffset
= startOffset;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>this.endOffset
= endOffset;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>this.kind =
kind;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public int getKind()</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>return kind;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public int
getStartOffset()</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>return startOffset;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public int
getEndOffset()</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>return endOffset;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public String
getValue(char[] inputChars)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>int len =
endOffset - startOffset + 1;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>return new
String(inputChars, startOffset, len);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>...</p>

<p class=MsoPlainText>}</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>There are only three attributes in this class: the kind, the
starting offset in the file (or character array) and the ending offset.<span
style='mso-spacerun:yes'>  </span>You might want to include a file attribute as
well.<span style='mso-spacerun:yes'>  </span></p>

<p class=MsoNormal>We did not do so because we think it better to place such
information in a “token stream” class.<span style='mso-spacerun:yes'> 
</span>The LEG token stream class is called <b>LexStream</b>.<span
style='mso-spacerun:yes'>  </span>It implements the LPG Java interface, <b>TokenStream,</b>
that specifies the operations on the token array the parser requires, such as <b>getToken()</b>,
<b>getKind(i)</b>, <b>getNext()</b>, <b>getPrevious()</b>, etc.<span
style='mso-spacerun:yes'>  </span>In addition , <b>LexStream</b> has methods to
create and build the token array list and access token attributes through a
token array index.<span style='mso-spacerun:yes'>  </span>Here is part of the <b>LexStream</b>
declaration:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>class LexStream implements TokenStream</p>

<p class=MsoPlainText>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>private int
index = 0;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>private int len
= 0;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>List tokens;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>CharStream
charStream;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>LexStream(CharStream charStream)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>this.charStream = charStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>tokens =
new ArrayList();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'> </span><span
style='mso-spacerun:yes'>       </span>addBadToken();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>void
addToken(Token token)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>tokens.add(token);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>. . .</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>String
getTokenText( int i )</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>Token t = (Token)tokens.get(i);</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>return t.getValue(charStream.inputChars);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>. . .</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>int getTokenLength(
int i )</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>Token t = (Token)tokens.get(i);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>return t.getEndOffset() - t.getStartOffset() +
1;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>int
getLineNumberOfTokenAt(int i)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>Token t = (Token)tokens.get(i);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>return
charStream.getLineNumberOfCharAt(t.getEndOffset());</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>int
getColumnOfTokenAt(int i)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>Token t = (Token)tokens.get(i);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span>return
charStream.getColumnOfCharAt(t.getStartOffset());</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>Token
getTokenAt(int i) { return (Token)tokens.get(i); }</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>. . .</p>

<p class=MsoPlainText>}</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>This class has methods for adding a token to the array list
and for getting various token attributes, such as its text, length and line and
column position in the character stream.<span style='mso-spacerun:yes'> 
</span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Thus, we need another class, a character stream class, that
accesses the array of characters from which the tokens are drawn.<span
style='mso-spacerun:yes'>  </span>Before discussing this class, you should note
that these stream classes are specified by the user – they are not part of the
LPG runtime.<span style='mso-spacerun:yes'>  </span>LPG has two interfaces the
user must implement: the <b>TokenStream</b> interface and the <b>RuleAction</b>
interface.<span style='mso-spacerun:yes'>  </span>In the future we may provide the
LPG runtime with token and character stream implementations as well as a
factory to create instances.<span style='mso-spacerun:yes'>  </span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h3>The Character Stream</h3>

<p class=MsoNormal>The array of tokens is generated by scanning (or lexing) the
input character stream.<span style='mso-spacerun:yes'>  </span>The approach
taken here is to read the entire input file into a character array and pass it
to a scanner class (which we call a character stream).<span
style='mso-spacerun:yes'>  </span>Traditionally, scanners for LR parsers
tokenize the input using either hand written methods or a table driven
deterministic finite automaton (DFA) .<span style='mso-spacerun:yes'> 
</span>For LL parser generator systems the scanner is sometimes specified with
an LL grammar so that parsing and lexing become indistinguishable – the parser
terminal symbols are tokens while the lexer’s are characters.<span
style='mso-spacerun:yes'>  </span>Like these LL systems, LPG allows you to
specify your lexer with an LR grammar.<span style='mso-spacerun:yes'> 
</span>You write your lexer in much the same way as you write your parser – a
lexer is just a parser with characters as tokens.<span
style='mso-spacerun:yes'>  </span>The AST produced by such a lexer-parser is
the token array list for your parser.</p>

<p class=MsoNormal>The LEG character stream class is called <b>CharStream</b>.<span
style='mso-spacerun:yes'>  </span>Here is a sample of its contents:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>class CharStream implements TokenStream, LegLexersym, </p>

<p class=MsoPlainText><span
style='mso-spacerun:yes'>                           
</span>LegLexerTokenKindMap, ParseErrorCodes</p>

<p class=MsoPlainText>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   </span><span
style='mso-spacerun:yes'> </span>private int index = -1;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>private int len
= 0;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>char[]
inputChars;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>int line = -1;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>int[]
lineOffsets;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>int newLength =
0;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>final static
int INITIAL = 4000;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>Option option;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>CharStream() {}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>CharStream(Option option)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>this.option =
option;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>inputChars =
option.getInputChars();</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>len =
inputChars.length;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>index = -1;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>inputChars[len - 2] = '\n';</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>inputChars[len
- 1] = '\uffff';</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>setLineOffset(-1);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>. . .</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>// Methods that
implement the TokenStream Interface</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public int
getToken()</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span><span style='mso-spacerun:yes'>  </span>index
= next(index);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span><span style='mso-spacerun:yes'>  </span>char c
= inputChars[index];</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>if (c &gt;
32)<span style='mso-spacerun:yes'>  </span>{ return index; }</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>if (c ==
10) { setLineOffset(index); return index; }</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span><span style='mso-spacerun:yes'>  </span>for
(;;index = next(index))</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span><span style='mso-spacerun:yes'>  </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>          </span><span
style='mso-spacerun:yes'>  </span>c = inputChars[next(index)];</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>if (c
&gt; 32 || c == 10) break;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>return
index;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public int
getKind( int i )</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span><span style='mso-spacerun:yes'>  </span>char c
= inputChars[i];</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>if (c &lt;
128) return tokenKind[c];</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>else if (c
== '\uffff') return Char_EOF;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>else return
Char_AfterASCII;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>. . .</p>

<p class=MsoPlainText>}</p>

<p class=MsoNormal>The <b>CharStream</b> class implements several interfaces,
most of which simply give access to constants.<span style='mso-spacerun:yes'> 
</span>Like the <b>LexStream</b> class, <b>CharStream</b> implements the LPG <b>TokenStream</b>
interface. <span style='mso-spacerun:yes'> </span>This is because an LPG parser
does the lexical analysis.<span style='mso-spacerun:yes'>  </span>You can see
that <b>CharStream</b> has required <b>TokenStream</b> methods, such as <b>getToken()</b><span
style='mso-spacerun:yes'>  </span>and <b>getKind(i)</b>.<span
style='mso-spacerun:yes'>  </span>Note also that a token is just an index into
the character array <b>inputChars</b>.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The <b>LegLexerSym</b> interface provides the values for the
lexical tokens (actually characters and character ranges) that are
scanned.<span style='mso-spacerun:yes'>  </span>Here is a sample of that
interface:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>interface LegLexersym {</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public final
static int</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_CtlCharNotNL = 1,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_Blank =
2,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     </span><span
style='mso-spacerun:yes'> </span>Char_NL = 3,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_a = 17,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_b = 36,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_c = 37,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>. . .</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_0 = 26,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_1 = 27,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_2 = 28,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_3 = 29,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>. . .</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_Plus =
7,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_Minus =
8,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_Slash =
5,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_Star =
6,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>. . .</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_AfterASCII = 51,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_EOF =
73,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>. . .</p>

<p class=MsoPlainText>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Notice that all control characters (except line feed) are
represented by a single token as are all characters above the ASCII range.<span
style='mso-spacerun:yes'>  </span>Again, the <b>int</b> values for the tokens
are assigned by LPG in a way that optimizes the size of the parse tables.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The <b>LegLexerTokenKindMap</b> interface<span
style='mso-spacerun:yes'>  </span>defines the mapping of character values to
token values.<span style='mso-spacerun:yes'>  </span>A small sample shows how
this is done:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>interface LegLexerTokenKindMap extends LegLexersym</p>

<p class=MsoPlainText>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>  </span><span
style='mso-spacerun:yes'>  </span>public final static int tokenKind[] =</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>. . .</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_CtlCharNotNL,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_CtlCharNotNL,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_NL,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_CtlCharNotNL,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_CtlCharNotNL,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>. . .</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_Blank,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_Exclaimation,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>. . .</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_z,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>  </span><span
style='mso-spacerun:yes'>    </span>Char_LeftBrace,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_VerticalBar,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_RightBrace,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>Char_Tilde,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>Char_AfterASCII</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>};</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The map is an array indexed by the first 128 ASCII
characters.<span style='mso-spacerun:yes'>  </span>The getKind(i) method uses
this array to classify the character as a token for the LPG parser.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The <b>CharStream</b> class needs to handle lexical
errors.<span style='mso-spacerun:yes'>  </span>It does this by implementing the
<b>reportError</b> method specified in the LPG <b>TokenStream</b>
interface.<span style='mso-spacerun:yes'>  </span>LPG lexers and parsers report
errors (lexical or syntactical) via the <b>reportError</b> method.<span
style='mso-spacerun:yes'>  </span>The <b>ParseErrorCodes</b> interface
enumerates the various kinds of errors and descriptive text so that an
appropriate message may be printed.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h2>The LEG Lexer</h2>

<p class=MsoNormal>The LEG lexer is actually an LPG parser much like the LEG
parser but with some important differences.<span style='mso-spacerun:yes'> 
</span>First, it uses a <b>CharStream</b> for character input and produces a <b>LexStream</b>
containing an array list of lexed tokens as output.<span
style='mso-spacerun:yes'>  </span>The LEG lexer uses a slightly modified LPG
parser because it is difficult to scan more than one token at a time
(especially key words which can be prefixes of identifiers) and because the
desired error recovery for a lexer is simply to skip (and report) unrecognized
characters.<span style='mso-spacerun:yes'>  </span>We have a special LPG parser
for lexical analysis, the LexParser.<span style='mso-spacerun:yes'>  </span></p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The LEG lexer has grammar rules for specifying tokens for
the LEG parser.<span style='mso-spacerun:yes'>  </span>You should peruse <b>leglexer.g</b>
in detail, but here we illustrate some of the rules for identifiers and
keywords.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Identifier<span style='mso-tab-count:1'>  </span>::=<span
style='mso-tab-count:1'>   </span>Ident</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>/.$DefaultAction</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>    </span>makeToken($getToken(1), $getSym(1),
$_IDENTIFIER);</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>  </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>Ident<span style='mso-tab-count:2'>       </span>::=<span
style='mso-tab-count:1'>   </span>Letter</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>/.$DefaultAction</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>    </span>$setSym1($getToken(1));</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>  </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>./</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>|<span
style='mso-tab-count:1'>     </span>Ident Letter</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>/.$DefaultAction</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>    </span>$setSym1($getToken(2));</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>  </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>./</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>|<span
style='mso-tab-count:1'>     </span>Ident Digit</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>/.$DefaultAction</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>    </span>$setSym1($getToken(2));</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-tab-count:1'>      </span><span style='mso-spacerun:yes'> 
</span>$EndAction</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>ReservedWord<span style='mso-tab-count:1'>      </span>::=<span
style='mso-tab-count:1'>   </span>b r e a k</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:2'>          </span>/.$DefaultAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:2'>          </span><span
style='mso-spacerun:yes'>    </span>keyWord($rule_size, $_BREAK);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:2'>          </span><span
style='mso-spacerun:yes'>  </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:2'>          </span>./</p>

<p class=MsoPlainText><span style='mso-tab-count:3'>                  </span>|<span
style='mso-tab-count:1'>     </span>d o</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:2'>          </span>/.$DefaultAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:2'>          </span><span
style='mso-spacerun:yes'>    </span>keyWord($rule_size, $_DO);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:2'>          </span><span
style='mso-spacerun:yes'>  </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>  </span><span
style='mso-spacerun:yes'>      </span><span style='mso-tab-count:2'>          </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>. . .</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Here are the two methods, <b>makeToken</b> and <b>keyWord</b>,
used in these rules:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>void makeToken(int startOffset, int
endOffset, int kind)</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>Token
t<span style='mso-spacerun:yes'>  </span>= new Token(startOffset, endOffset,
kind);</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>$prs_stream.addToken(t);</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>printValue(t);</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>void keyWord(int size, int kind)</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>Token
t<span style='mso-spacerun:yes'>  </span>= new Token($getToken(1),
$getToken(size), kind);</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>t.setStartOffset($getToken(1));</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>$prs_stream.addToken(t);</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>printValue(t);</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Both methods create a token (using the starting and ending
offsets and kind) and add it to the <b>LexStream’s</b> tokens list (note that
the token stream is named by the macro <b>$prs_stream</b>).<span
style='mso-spacerun:yes'>  </span>(The <b>printValue</b> method prints out the
value of the token under a debugging option.) </p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The rules for <b>Identifier</b> and <b>ReservedWord</b>
illustrate how an LPG lexer uses the “sym” stack.<span
style='mso-spacerun:yes'>  </span>In the LPG<span style='mso-spacerun:yes'> 
</span>LexParser the “sym” stack holds integers, not Objects and no “AST” is
defined or returned.<span style='mso-spacerun:yes'>  </span>The integer our
actions place on the sym stack (using the method <b>setSym1(i)</b>) is the location
of the rightmost character reduced to that left hand side.<span
style='mso-spacerun:yes'>  </span>Thus, invoking <b>getSym(i)</b> in a rule
action retrieves the index in the character stream of the rightmost character
scanned for that non-terminal symbol.<span style='mso-spacerun:yes'> 
</span>You may recall that invoking <b>getToken(i)</b> on a non-terminal symbol
obtains the index of the leftmost character scanned for that symbol.<span
style='mso-spacerun:yes'>  </span>The right hand side of the <b>Identifier</b>
rule is the single non-terminal <b>Ident</b>.<span style='mso-spacerun:yes'> 
</span>Its start offset is given by <b>$getToken(1)</b> and its end offset by <b>$getSym(1)</b>.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The same is done for the reserved words.<span
style='mso-spacerun:yes'>  </span>However, in this case, the right had side
consists in spelling out the letters of the word (whose characters are just
tokens for this lexer).<span style='mso-spacerun:yes'>  </span>Although it is
easy enough to get the starting offset of the reserved word, we need some help
from LPG to get the ending offset.<span style='mso-spacerun:yes'>  </span>LPG
has a predefined macro, <b>$rulesize</b>, that gives the size (or length) of
the right hand side of the current rule (the one in whose action block the
macro is used).<span style='mso-spacerun:yes'>  </span>Thus,
$getToken($rulesize) gets the index of the last terminal symbol in a rule,
which, in this example, is the end offset of the reserved word.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>It is important also to understand how we obtain the token
kind.<span style='mso-spacerun:yes'>  </span>The LEG parser needs the token
kind in order to parse the token stream.<span style='mso-spacerun:yes'> 
</span>We could get access to the token kind in the following way.<span
style='mso-spacerun:yes'>  </span>We run LPG on the LEG parser grammar which defines
all the terminal symbols – IDENTIFIER, PLUS, BREAK, etc. – and make available
to the LEG lexer the “sym” interface, <b>LegParsersym</b>, which contains all these
symbols prefixed with “<b>TK_</b>” with their integer values.<span
style='mso-spacerun:yes'>  </span>Then the lexer actions could name the token
kind directly.<span style='mso-spacerun:yes'>  </span>For example, <span
style='mso-spacerun:yes'> </span>the lexer non-terminal symbol “<b>Identifier</b>”
represents the parser terminal symbol “<b>TK_IDENTIFIER</b>”.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>While this approach works, it is obviously not desirable
since it is not easily maintainable and very error prone.<span
style='mso-spacerun:yes'>  </span>We have added to LPG an “export/import”
capability somewhat analogous to that found in ANTLR.<span
style='mso-spacerun:yes'>  </span>A grammar file may have a <b>$Export</b> section
in which the terminal symbols to be exported to another grammar are
enumerated.<span style='mso-spacerun:yes'>  </span>In addition, there is an
option “<b>export_terminals</b>” that specifies a “sym” file for the exported
terminals.<span style='mso-spacerun:yes'>  </span>The LEG lexer exports all of
the terminal symbols that will be used in the LEG parser.<span
style='mso-spacerun:yes'>  </span>The export_terminals option tells LPG to
create a Java “sym” interface for the exported symbols using the specified
prefix (if any) and assign values to the symbol names in the order of
appearance in the export section.<span style='mso-spacerun:yes'>  </span>In the
LEG lexer this option is stated as follows:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>%options export_terminals=(&quot;LegParsersym.java&quot;,
&quot;TK_&quot;)</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The LEG lexer has the following export section,</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Export</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>ASSIGN<span
style='mso-spacerun:yes'>  </span>LEFT_BRACKET<span style='mso-spacerun:yes'> 
</span>RIGHT_BRACKET SEMICOLON</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>PLUS<span
style='mso-spacerun:yes'>  </span>MINUS<span style='mso-spacerun:yes'> 
</span>DIVIDE<span style='mso-spacerun:yes'>  </span>STAR</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>   
</span>LEFT_PARENTHESIS RIGHT_PARENTHESIS</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>IDENTIFIER
CONSTANT EOF_SYMBOL</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>IF THEN ELSE
END WHILE DO BREAK</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>IDENTIFIER</p>

<p class=MsoPlainText>$End</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>for which the following interface is generated:</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>interface LegParsersym {</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public final
static int</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_ASSIGN =
1,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>TK_LEFT_BRACKET = 2,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>TK_RIGHT_BRACKET = 3,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_SEMICOLON
= 4,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_MINUS = 6,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_DIVIDE =
7,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_STAR = 8,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>TK_LEFT_PARENTHESIS = 9,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>     
</span>TK_RIGHT_PARENTHESIS = 10,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_IDENTIFIER
= 11,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_CONSTANT =
12,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_EOF_SYMBOL
= 13,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_IF = 14,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_THEN = 15,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_ELSE = 16,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_END = 17,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_WHILE =
18,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_DO = 19,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_BREAK =
20,</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>TK_IDENTIFIER
= 21,</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span>NUM_TOKENS =
21;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public final
static boolean isValidForParser = false;</p>

<p class=MsoPlainText>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>This is not a sym file the LEG parser can use, because the
LPG values for terminal symbols are determined by the parse table compression
algorithm.<span style='mso-spacerun:yes'>  </span>Thus, there is a boolean
constant <b>isValidForParser</b> to indicate that this sym interface is
invalid.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Having names for the exported symbols enables you to assign
kinds to the lexed tokens.<span style='mso-spacerun:yes'> 
</span>Unfortunately, using the prefix (“<b>TK_</b>” for the LEG example) makes
the actions less readable and can lead to errors should this prefix not agree
with the one specified in the parser file.<span style='mso-spacerun:yes'> 
</span>To remedy this situation LPG introduces a macro for each exported
symbol.<span style='mso-spacerun:yes'>  </span>The form is simply “<b>_&lt;terminal&gt;</b>”
and you reference the symbol with “<b>$_&lt;terminal&gt;</b>”.<span
style='mso-spacerun:yes'>  </span>Thus, <b>$_IDENTIFIER </b><span
style='mso-spacerun:yes'> </span>and <b>$_BREAK</b> represent the kind of <b>TK_IDENTIFIER</b>
and <b>TK_BREAK</b> respectively.<span style='mso-spacerun:yes'>  </span>This
makes references to exported names independent of the prefix.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Just as the LEG lexer exports terminal symbols, the LEG
parser imports them.<span style='mso-spacerun:yes'>  </span>The LEG parser has
the following option to import its terminals from the LEG lexer:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>%options import_terminals=LegLexer.g</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Notice that the lexer grammar file is indicated, not the
symbol file, <b>LegParsersym.java</b>.<span style='mso-spacerun:yes'> 
</span>LPG reads the imported grammar file and takes all the terminals it
exports as its own.<span style='mso-spacerun:yes'>  </span>The importing
grammar may include these (and other) terminal symbols in a <b>$Terminals</b>
section.<span style='mso-spacerun:yes'>  </span>However, you should ensure that
it specifies the same symbol file and prefix as the imported grammar file.<span
style='mso-spacerun:yes'>  </span>When LPG generates the parser symbol file using
the name specified in the imported grammar file (<b>LegParsersym.java</b>), it includes
the imported token names (prefixed as specified in the imported file) but with
their correct values.<span style='mso-spacerun:yes'>  </span>The <b>isValidForParser</b>
flag will be set <b>true</b>.<span style='mso-spacerun:yes'>  </span>The
backtracking or deterministic parser constructor throws the<span
style='mso-spacerun:yes'>  </span><b>BadParseSymFileException</b> if this flag
is <b>false</b>.<span style='mso-spacerun:yes'>  </span>This guarantees that
the symbol file generated by the parser is used when compiling parser and lexer
together.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>When terminal symbols are imported into a grammar file (as,
for example, the exported terminals of <b>LegLexer.g</b> are imported by <b>LegParser.g</b>),<span
style='mso-spacerun:yes'>  </span>LPG effectively includes the imported grammar
file and processes it before processing the importing file.<span
style='mso-spacerun:yes'>  </span>Thus, the command,</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>C:\legexample\leg&gt;lpg legparser.g</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>processes first the lexer and then the parser grammar files.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The lexer’s action class, <b>LegLexer</b>, is somewhat
different from the parser’s class, <b>LegParser</b>.<span
style='mso-spacerun:yes'>  </span>Here is part of the Java declaration:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>public class LegLexer implements RuleAction, LegParsersym</p>

<p class=MsoPlainText>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>CharStream
lexStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>LexStream
prsStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>ParseTable prs;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>LexParser
lexParser;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public
LegLexer(CharStream lexStream)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>this.lexStream
= lexStream;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>this.prsStream
= new LexStream(lexStream);</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>this.prs = new
LegLexerprs();</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>this.lexParser
= new LexParser((TokenStream)lexStream, </p>

<p class=MsoPlainText><span
style='mso-spacerun:yes'>                                     </span>prs,
(RuleAction)this);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public
LexStream lexer()</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>lexParser.parseCharacters();</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>prsStream.addEofToken(TK_EOF_SYMBOL);</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>return
prsStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>. . .</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Notice that the constructor requires a <b>CharStream</b> and
creates a <b>LexParser</b> passing it a <b>TokenStream</b>, a <b>ParseTable</b>
and a <b>RuleAction</b>.<span style='mso-spacerun:yes'>  </span>The <b>lexer</b>
method, invoked from the main or driver class, parses the character stream into
a LexStream which is returned to the driver.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h2>Templates</h2>

<p class=MsoNormal>No doubt you noticed that producing a parser or lexer
involves specifying quite a bit more than the symbols, the grammar rules and
the rule actions.<span style='mso-spacerun:yes'>  </span>In addition to various
LPG options, you need a <b>$Define</b> section and a <b>$Header</b> section,
both of which are similar for each parser or lexer you write.<span
style='mso-spacerun:yes'>  </span>To simplify your task LPG offers several
predefined grammar file <b>templates</b>.<span style='mso-spacerun:yes'> 
</span>Using the<span style='mso-spacerun:yes'>  </span>template option you
essentially include the specified template file at the beginning of your
grammar file.<span style='mso-spacerun:yes'>  </span>These are the presently
available template files for Java written parsers:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='mso-list:l11 level1 lfo11;tab-stops:list .5in'><b>btParserTemplate.g<o:p></o:p></b></li>
 <li class=MsoNormal style='mso-list:l11 level1 lfo11;tab-stops:list .5in'><b>btParserTemplateA.g<o:p></o:p></b></li>
 <li class=MsoNormal style='mso-list:l11 level1 lfo11;tab-stops:list .5in'><b>dtParserTemplate.g<o:p></o:p></b></li>
 <li class=MsoNormal style='mso-list:l11 level1 lfo11;tab-stops:list .5in'><b>dtParserTemplateA.g<o:p></o:p></b></li>
 <li class=MsoNormal style='mso-list:l11 level1 lfo11;tab-stops:list .5in'><b>LexerTemplate.g<o:p></o:p></b></li>
 <li class=MsoNormal style='mso-list:l11 level1 lfo11;tab-stops:list .5in'><b>LexerTemplateA.g<o:p></o:p></b></li>
</ul>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Here “bt” denotes the backtracking parser and “dt” the
deterministic parser.<span style='mso-spacerun:yes'>  </span>The lexer template
uses the lex parser.<span style='mso-spacerun:yes'>  </span>The letter “A”
suffix indicates an alternative approach to specifying rule actions.<span
style='mso-spacerun:yes'>  </span>Instead of calling one action method
consisting of a select statement with a case alternative for each rule, an array
of action class instances, one for each rule and containing a single method, is
indexed by the rule number and the rule action for that instance is invoked.<span
style='mso-spacerun:yes'>  </span>LPG defined macros simplify the writing
actions that define a class with an action method and creating an instance of
the class in the array of action instances.<span style='mso-spacerun:yes'> 
</span>In fact, with these templates you write you actions the same way,
regardless whether you use the “select” or the “class instance” style.<span
style='mso-spacerun:yes'>  </span>The alternative approach does not appear to
be as efficient as the standard one.<span style='mso-spacerun:yes'>  </span>However,
for grammars with many rule actions you may need it since Java places a 64K
restriction on compiled object size.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>You can modify these templates to suit the needs of your
project.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The LEG lexer uses <b>LexerTemplate.g</b>.<span
style='mso-spacerun:yes'>  </span>This is what that template contains:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>-- An LPG Lexer Template Using lpg.jar</p>

<p class=MsoPlainText>--</p>

<p class=MsoPlainText>-- An instance of this template must have a $Export
section and the</p>

<p class=MsoPlainText>-- export_terminals option</p>

<p class=MsoPlainText>--</p>

<p class=MsoPlainText>-- Macros that must be defined in an instance of this
template</p>

<p class=MsoPlainText>--</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>    
</span>$package_declaration</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>    
</span>$import_classes</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>    
</span>$action_class</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>    
</span>$lex_stream_class</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>     </span>$prs_stream_class</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>     </span>$eof_token</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>%Options escape=$,table=java,margin=8,nobacktrack</p>

<p class=MsoPlainText>%options action=(&quot;*.java&quot;, &quot;/.&quot;,
&quot;./&quot;)</p>

<p class=MsoPlainText>%options ParseTable=lpg.*</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Notice /.$copyright./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Define</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$copyright</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/.</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>/*************************************************************</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*
COPYRIGHT:</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*<span
style='mso-spacerun:yes'>     </span>(C) COPYRIGHT IBM CORPORATION 2002</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>* <span
style='font-size:8.0pt'>The source code for this program is not published or
otherwise divested of</span></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>* <span
style='font-size:8.0pt'>its trade secrets, irrespective of what has been deposited
with the </span><st1:country-region><st1:place><span style='font-size:8.0pt'>U.S.</span></st1:place></st1:country-region></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>* <span
style='font-size:8.0pt'>Copyright Office.</span></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>* Source
File Name: %W%</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>* Version:
%I%, %G%</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*
Descriptive Name:</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>* Function:</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>* Change
Activity:</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>*************************************************************/</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>./</p>

<p class=MsoPlainText>--</p>

<p class=MsoPlainText>-- Macros that may be needed in an instance of this
template</p>

<p class=MsoPlainText>--</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$setSym1
/.lexParser.setSym1./</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$getSym
/.lexParser.getSym./</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$getToken
/.lexParser.getToken./</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$lex_stream
/.lexStream./</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$prs_stream
/.prsStream./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$Header</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/.</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>//</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>// Rule
$rule_number:<span style='mso-spacerun:yes'>  </span>$rule_text</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>//./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>$DefaultAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/. $Header</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>case $rule_number:</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>{ ./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$BeginAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-spacerun:yes'>    </span>/.$DefaultAction./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$EndAction</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>/.</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                   
</span>break; ./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>--</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>-- This
macro is used to reset the parser's state stack</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>-- after a
Token has been reduced.</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>$ResetStackAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/. $Header</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           </span><span
style='mso-tab-count:1'> </span><span style='mso-spacerun:yes'>    </span>case
$rule_number:</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                      
</span>lexParser.resetStateStack();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                      
</span>break; ./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$NoAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/. $Header</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           </span><span
style='mso-tab-count:1'> </span><span style='mso-spacerun:yes'>    </span>case
$rule_number:</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                       
</span>break; ./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>$BeginActions</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>      </span><span
style='mso-spacerun:yes'>  </span>/.</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>public void ruleAction( int ruleNumber)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:1'>  </span><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>switch(ruleNumber)</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$EndActions</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>/.</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>    </span>default:</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span><span
style='mso-spacerun:yes'>        </span>break;</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>}</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>return;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$End</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Headers</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/.</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>$copyright</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$package_declaration</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>$import_classes</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>  </span>import lpg.*;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>public
class $action_class implements RuleAction, $exp_type</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>$lex_stream_class lexStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>$prs_stream_class prsStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>ParseTable prs;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>LexParser lexParser;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>public $action_class($lex_stream_class
lexStream)</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>this.$lex_stream
= lexStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:1'>    </span>this.prsStream = new
$prs_stream_class(lexStream);</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>this.prs
= new $prs_type();</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>this.lexParser
= new LexParser((TokenStream)lexStream, </p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>               </span><span
style='mso-spacerun:yes'>                            </span>prs,
(RuleAction)this);</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>public
$prs_stream_class lexer()</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span><span
style='mso-tab-count:2'>        </span>lexParser.parseCharacters();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span><span
style='mso-tab-count:1'>    </span>prsStream.addEofToken($eof_token);</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>return
prsStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$End</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Rules</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>/.$BeginActions./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$End</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Trailers</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>/.</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>    </span>$EndActions</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>}</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$End</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The template contains a copyright notice that, thanks to the
<b>$Notice</b> section,<span style='mso-spacerun:yes'>  </span>will be placed
at the head of each file LPG generates.<span style='mso-spacerun:yes'>  </span>You
may wish to edit or remove the <b>$copyright</b> macro.<span
style='mso-spacerun:yes'>  </span>Notice that <b>$copyright</b> is the first
macro invoked in the <b>$Header</b> section of the template (to ensure that it
appears in the action file).<span style='mso-spacerun:yes'>  </span>If you are
not using templates you may obtain the same effect by including a <b>$Notice</b>
section in your grammar file.<span style='mso-spacerun:yes'>  </span>This
section has zero or more action blocks.<span style='mso-spacerun:yes'> 
</span>Moreover you can have more than one <b>$Notice</b> section.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>In <b style='mso-bidi-font-weight:normal'>LegLexer.g</b>
this template is specified as follows:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>%options template=LexerTemplate.g</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The result are abbreviated <b>$Define</b> and <b>$Headers</b>
sections.<span style='mso-spacerun:yes'>  </span>In fact, we only need to
define the macros used in the lexer template and specify additional methods for
use in LegLexer actions.<span style='mso-spacerun:yes'>  </span>Notice, that
the various sections can appear in any order.</p>

<p class=MsoNormal>The LEG parser uses <b>btParserTemplate.g</b>.<span
style='mso-spacerun:yes'>  </span>This is some of what the template contains:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>--</p>

<p class=MsoPlainText>-- An LPG Parser Template Using lpg.jar</p>

<p class=MsoPlainText>--</p>

<p class=MsoPlainText>-- In a parser using this template, define the following
macros:</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>    
</span>$package_declaration</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>    
</span>$import_classes</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>    
</span>$action_class</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>    
</span>$prs_stream_class</p>

<p class=MsoPlainText>--<span style='mso-spacerun:yes'>     </span>$ast_class</p>

<p class=MsoPlainText>--</p>

<p class=MsoPlainText>%Options escape=$,table=java,margin=8,backtrack</p>

<p class=MsoPlainText>%options action=(&quot;*.java&quot;, &quot;/.&quot;,
&quot;./&quot;)</p>

<p class=MsoPlainText>%options ParseTable=lpg.*</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Define</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$Header</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>. . .<span
style='mso-spacerun:yes'>  </span>(same as the lexer template above)</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>--</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>-- Macros that
may be needed in a parser using this template</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>--</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$setSym1
/.btParser.setSym1./</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$getSym
/.($ast_class)btParser.getSym./</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$getToken
/.btParser.getToken./</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>$prs_stream
/.prsStream./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$End</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$Headers</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>/.</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>       
</span>$package_declaration</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>$import_classes</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>import
lpg.*;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>public
class $action_class implements RuleAction</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>$prs_stream_class prsStream;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>ParseTable prs;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>BacktrackingParser btParser;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>public
$action_class($prs_stream_class prsStream)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>                </span>. .
. (already shown above)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>public
$ast_class parser()</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>              </span>. . .
(already shown above)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>./</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>$End</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>. . .</p>

<p class=MsoNormal>In LegParser.g this template is specified as follows:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText>%options template=btParserTemplate.g</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>Using the template simplifies the <b>$Define</b> section and
eliminates the <b>$Headers</b> and <b>$Trailers</b> sections.</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<h2>Putting the Pieces Together</h2>

<p class=MsoNormal>The LEG example has a number of components.<span
style='mso-spacerun:yes'>  </span>These are:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list .5in'>The
     LEG grammar files (<b>LegLexer.g </b>and<b> LegParser.g</b>)</li>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list .5in'>The
     LPG template files (<b>LexerTemplate.g </b>and<b> btParserTemplate.g</b>)</li>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list .5in'>The
     LPG runtime (<b>lpg.jar</b>)</li>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list .5in'>The
     various AST classes (too many to enumerate here)</li>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list .5in'>The
     token stream classes (<b>CharStream </b>and<b> LexStream</b>)</li>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list .5in'>The
     Token class (<b>Token</b>)</li>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list .5in'>The
     Option class (<b>Option</b>)</li>
 <li class=MsoNormal style='mso-list:l10 level1 lfo12;tab-stops:list .5in'>The
     main program (<b>Main</b> class)</li>
</ul>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>The main program puts these parts together by determining
the options, reading the input file, creating the character stream, invoking
the lexer and finally invoking the parser.<span style='mso-spacerun:yes'> 
</span>Here essentially is what it does:</p>

<p class=MsoNormal><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>public static
void main(String[] args)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>Option option;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>LegLexer
legLexer;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>LegParser
legParser;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>CharStream
charStream;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>LexStream
lexStream;</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span>Ast root;</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>try</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>{</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>option
= new Option(args);</p>

<p class=MsoPlainText><span style='mso-tab-count:1'>      </span><span
style='mso-spacerun:yes'>      </span>int rlen = option.readInputChars();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>charStream = new CharStream(option);</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>legLexer = new LegLexer(charStream); </p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>lexStream = legLexer.lexer();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>           
</span>legParser = new LegParser(lexStream); </p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>root =
legParser.parser();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>            </span>return;</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>catch (Exception
e)</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>{</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>System.err.println(e.getMessage());</p>

<p class=MsoPlainText><span style='mso-tab-count:2'>            </span>e.printStackTrace();</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>        </span>}</p>

<p class=MsoPlainText><span style='mso-spacerun:yes'>    </span>}</p>

<p class=MsoPlainText><o:p>&nbsp;</o:p></p>

<p class=MsoNormal>We hope that with the LEG example as a model you can build
LPG lexers and parsers for your own applications.<o:p></o:p></p>

</div>

</body>

</html>
